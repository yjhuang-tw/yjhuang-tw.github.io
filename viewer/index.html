<!DOCTYPE html>
<html>
<head>

    <title>Viewer</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="three.js"></script>
    <script src="Detector.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>

    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            background: hsl(0, 0%, 10%);
        }

    </style>

</head>
<body>

<div stlye="position: relative; width: 100%;">

	<div style="background-color: white; width: 150px; position: absolute; height:100%; padding:20px;">
		<h2 style="padding-top:20px;">Object:</h2>
		<p id="demo"></p>	
	</div>
	

    <script>
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }

        var container;

        var camera, controls, scene, renderer;
        var lighting, ambient, keyLight, fillLight, backLight;

		
		init();
        animate();
		

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            /* Camera */

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 10;

            /* Scene */

            scene = new THREE.Scene();
            lighting = true;

			
			/* Lighting*/
			
            ambient = new THREE.AmbientLight(0x333333, 1.0);
            
			const light = new THREE.HemisphereLight( 0xffffff, 0x888888 );
			light.position.set( 2.0, 1, 0 );
			
			scene.add(ambient);
			scene.add( light );


            /* Model */

			const mtlLoader = [];
			const objLoader = [];
			const xmlhttp = new XMLHttpRequest();
			xmlhttp.onload = function()
			{
				const myArr = JSON.parse(this.responseText);
			  	    
				for (let i = 0; i < myArr.items.length; i++)
				{
					let mesh_name = document.getElementById("demo").innerHTML = myArr.items[i].mesh_name;
					
					mtlLoader[i] = new THREE.MTLLoader();
					mtlLoader[i].setBaseUrl('assets/'+ mesh_name +'/');
					mtlLoader[i].setPath('assets/'+ mesh_name +'/');
					mtlLoader[i].load( mesh_name + '.mtl', function (materials)
					{
						materials.preload();

						materials.materials.default.map.magFilter = THREE.NearestFilter;
						materials.materials.default.map.minFilter = THREE.LinearFilter;

						objLoader[i] = new THREE.OBJLoader();
						objLoader[i].setMaterials(materials);
						objLoader[i].setPath('assets/'+ mesh_name +'/');
						objLoader[i].load( mesh_name + '.obj', function (object)
						{	
							object.machine_id = myArr.items[i].machine_id;
							object.show_type = myArr.items[i].type;
							
							object.translateX(-myArr.items[i].x);
							object.translateY(myArr.items[i].y-1.5);
							object.translateZ(myArr.items[i].z);
							
							scene.add(object);
						});
					});				
				}
			}
			xmlhttp.open("GET", "build_setting.json", true);
			xmlhttp.send();


            /* Renderer */

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));

            container.appendChild(renderer.domElement);


            /* Controls */

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;


            /* Events */

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyboardEvent, false);
			
			window.addEventListener( 'click', onMouseClick, false );
			window.addEventListener( 'pointermove', onMouseMove, false );
			
        }



		/* OnMouseClick */
		
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();

		function onMouseClick( event ) {

			//通過滑鼠點選的位置計算出raycaster所需要的點的位置，以螢幕中心為原點，值的範圍為-1到1.
			const rect = renderer.domElement.getBoundingClientRect();
			mouse.x = ( ( event.clientX - rect.left ) / ( rect.right - rect.left ) ) * 2 - 1;
			mouse.y = - ( ( event.clientY - rect.top ) / ( rect.bottom - rect.top) ) * 2 + 1;

			// 通過滑鼠點的位置和當前相機的矩陣計算出raycaster
			raycaster.setFromCamera( mouse, camera );

			// 獲取raycaster直線和所有模型相交的陣列集合
			var intersects = raycaster.intersectObjects( scene.children, true );

			console.log(intersects);

			if( intersects.length > 0 )
			{
				document.getElementById("demo").innerHTML = intersects[0].object.parent.machine_id;
				
				if(intersects[0].object.parent.show_type == "outside")
				{
					let mid = intersects[0].object.parent.machine_id;
					document.getElementById("demo").innerHTML = '<img src="assets/img/'+mid+'.png">';
				}
				else if(intersects[0].object.parent.show_type == "outside")
				{
				}
			}
			
		}
		
		/* OnMouseMove */
		
		var currInter;
		function onMouseMove( event ) {

			const rect = renderer.domElement.getBoundingClientRect();
			mouse.x = ( ( event.clientX - rect.left ) / ( rect.right - rect.left ) ) * 2 - 1;
			mouse.y = - ( ( event.clientY - rect.top ) / ( rect.bottom - rect.top) ) * 2 + 1;
			
			raycaster.setFromCamera( mouse, camera );

			// 獲取raycaster直線和所有模型相交的陣列集合
			var intersects = raycaster.intersectObjects( scene.children, true );


			if ( intersects.length > 0 ) {

				if ( currInter != intersects[ 0 ].object ) {

					if ( currInter ) currInter.material.emissive.setHex( currInter.currentHex );

						currInter = intersects[ 0 ].object;
						currInter.currentHex = currInter.material.emissive.getHex();
						currInter.material.emissive.setHex( 0x333333 );
				}
			}
			else {
			
				if ( currInter ) currInter.material.emissive.setHex( currInter.currentHex );
				
				currInter = null;
			}
			

		}



        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function onKeyboardEvent(e) {

            if (e.code === 'KeyL') {

                lighting = !lighting;

                if (lighting) {

                    ambient.intensity = 0.25;
                    scene.add(keyLight);
                    scene.add(fillLight);
                    scene.add(backLight);

                } else {

                    ambient.intensity = 1.0;
                    scene.remove(keyLight);
                    scene.remove(fillLight);
                    scene.remove(backLight);

                }
            }
        }
        function animate() {

            requestAnimationFrame(animate);

            controls.update();

            render();

        }
        function render() {

            renderer.render(scene, camera);

        }
    </script>	
	
	
</div>








</body>
</html>
